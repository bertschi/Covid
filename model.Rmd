---
title: "COVID-19 modeling"
author: "Nils Bertschinger & Rajbir Nirwan"
date: "17.03.2020"
options:
  doctype: md2html
  out_path: reports/model.html
---

```{r, echo=FALSE}
## knitr::opts_chunk$set(engine.path = list(
##   julia = '/home/bertschi/Software/julia-1.3.0/bin'
## ))
```


```{julia}
using Plots
using DifferentialEquations
using Distributions
using Random
Random.seed!(123);
```

# Some thoughts on epidemic modeling

The current COVID-19 pandemic is spreading and policy makers around
the globe implement restrictive measures trying to curtail it. Yet,
much is unknown/uncertain and the question remains: *How effective are
current measures and can they work at all?*

## Epidemic models

Most epidemic models rely on differential equations, e.g. the famous
SIR model. Here, we will discuss these and related models in order to
understand their dynamics. In turn, we will fit models to recent data
and investigate possible scenarios ...

### The SEIR model

The SEIR model adds an incubation period (exposed) to the classical
SIR (susceptible-infected-recovered) model. Its dynamics is given as

$$
\begin{align*}
	\frac{dS}{dt} &= \Lambda - \mu S - \beta \frac{I}{N} S \\
	\frac{dE}{dt} &= \beta \frac{I}{N} S - (\mu + a) E \\
	\frac{dI}{dt} &= a E - (\gamma + \mu) I \\
	\frac{dR}{dt} &= \gamma I - \mu R
\end{align*}
$$

with $N = S + E + I + N$ and transition rate parameters $\beta, a$ and
$\gamma$. In addition, a general birth $\Lambda$ and death rate $\mu$
of the population is assumed. Here, as the infection spreads much
faster than the population develops, we will assume that $\Lambda =
\mu \equiv 0$.

Then, susceptible individual become infected with rate $\beta
\frac{I}{N}$ and the transition through the states $E \to I \to
R$. The time spend in states $E$ and $I$ are exponentially distributed
with averages $a^{-1}$ and $\gamma^{-1}$ respectively. Especially this part of
the model appears somewhat unrealistic and is an artifact of the use
of differential equations instead of more elaborate models,
e.g. integro-differential equations.

```{julia}
struct SEIRModel
    Λ
    μ
    β
    a
    γ
end

function seirdynamics!(du, u, θ::SEIRModel, t)
    S, E, I, R = u
    N = S + E + I + R
    du[1] = θ.Λ - θ.μ * S - θ.β * I / N * S
    du[2] = θ.β * I / N * S - (θ.μ + θ.a) * E
    du[3] = θ.a * E - (θ.γ + θ.μ) * I
    du[4] = θ.γ * I - θ.μ * R
end
```

```{julia}
θ = SEIRModel(0.0, 0.0, 0.5, 1/3, 0.2)
u₀ = [1.0e6 - 1, 0.0, 1.0, 0.0]
tspan = (0.0, 250.0)
seir = ODEProblem(seirdynamics!, u₀, tspan, θ)
sol = solve(seir)
plot(sol)
```

### Agent-based model

Here, we consider a similar agent-based model where each agent
deterministically transitions through the states $E \to I \to R$ after
some fixed time.

```{julia}
struct AgentState
    tag::Symbol
    τ::Int
end

struct AgentParams
    β::Float64
    τₑ::Int64
    τᵢ::Int64
end

function agentstep(s::AgentState, θ::AgentParams, pᵢ)
    if (s.tag == :S) && (rand() < pᵢ)
        ## Become exposed for τₑ days
        AgentState(:E, θ.τₑ)
    elseif (s.tag == :E)
        if (s.τ > 1)
            AgentState(:E, s.τ - 1)
        else
            ## Become infected for τᵢ days
            AgentState(:I, θ.τᵢ)
        end
    elseif (s.tag == :I)
        if (s.τ > 1)
            AgentState(:I, s.τ - 1)
        else
            ## Recover
            AgentState(:R, 0)
        end
    else
        ## Return state unchanged
        s
    end
end

function populationstep(pop::AbstractVector{AgentState}, θ::AgentParams)
    N = length(pop)
    I = count(s -> s.tag == :I, pop)
    S = count(s -> s.tag == :S, pop)
    pᵢ = θ.β * I / N
    @show pᵢ
    [ agentstep(s, θ, pᵢ) for s in pop ]
end

function populationstats(pop::AbstractVector{AgentState})
    [count(a -> a.tag == :S, pop),
     count(a -> a.tag == :E, pop),
     count(a -> a.tag == :I, pop),
     count(a -> a.tag == :R, pop)]
end

function simulate(x₀, step, n; stats = identity)
    x = x₀
    sim = [stats(x)]
    for i = 1:n
        x = step(x)
        push!(sim, stats(x))
    end
    sim
end
```

```{julia}
θ = AgentParams(0.5, 3, 5)
pop₀ = vcat(repeat([AgentState(:I, 5)], 1),
            repeat([AgentState(:S, 0)], 1000000 - 1))
sim = simulate(pop₀, p -> populationstep(p, θ), 250;
               stats = populationstats)
plot(hcat(sim...)')
```

Note that the model has a notably different dynamics than the SEIR
model! The epidemic spreads even faster when using the more realistic
progression of the infection compared to the exponentially distributed
times.

### Discrete, statistical model

#### Version 1

This model is based on the observation that all state variables and
transitions (of the agent-based model) can be computed from the time
series of newly infected individuals each day [This model has been
developed with Raj].

Assume that we know the number of new infections $\Delta I_t$ at each
time. Then, the state variables are recovered as

$$
\begin{align*}
	S_t &= N - \sum_{\tau = 0}^{\infty} \Delta I_{t-\tau} \\
	E_t &= \sum_{\tau = 0}^{\tau_E-1} \Delta I_{t-\tau} \\
	I_t &= \sum_{\tau = \tau_E}^{\tau_E + \tau_I - 1} \Delta I_{t-\tau} \\
	R_t &= \sum_{\tau = \tau_E + \tau_I}^{\infty} \Delta I_{t-\tau}
\end{align*}
$$

and the dynamics of new infections reads

$$
	\Delta I_{t+1} = \beta \frac{I_t}{N} S_t
$$

```{julia}
struct DeltaParams
    N
    β::Float64
    τₑ::Int64
    τᵢ::Int64
end

function deltastats(ΔI::AbstractVector, θ::DeltaParams)
    ## Note: ΔI is stored backwards in time, i.e. newest at smallest index
    S = θ.N - sum(ΔI)
    E = sum(ΔI[1:θ.τₑ])
    I = sum(ΔI[θ.τₑ .+ (1:θ.τᵢ)])
    R = θ.N - (S + E + I)
    [S, E, I, R]
end

function deltastep(ΔI::AbstractVector, θ::DeltaParams)
    S, E, I, R = deltastats(ΔI, θ)
    ## vcat(θ.β * I / θ.N * S, ΔI)
    vcat(rand(Binomial(S, θ.β * I / θ.N)), ΔI)
end
```

```{julia}
θ = DeltaParams(1000000, 0.5, 3, 5)
sim = simulate(vcat([1], repeat([0], θ.τₑ + θ.τᵢ)),
               ΔI -> deltastep(ΔI, θ), 250;
               stats = ΔI -> deltastats(ΔI, θ))
plot(hcat(sim...)')
```

#### Version 2

A more realistic version of the above model can be defined, by
relaxing the assumption of deterministic transitions after a fixed
number of days. This can for example be achieved by using a
weighting/survival function giving the probability that an agent is
still exposed/infected after a certain number of days. E.g. the number
of exposed agents is then given as $E_t = \sum_{\tau = 0}^{\infty}
w_E(\tau) \Delta I_{t-\tau}$ where $w_E(\tau) = 1 - \frac{1}{1 + e^{-
\alpha_E (\tau - \tau_E)}}$ for instance.

Compared to the differential equation SEIR model, such a model has
several advantages:

* It is more realistic and can easily be extended to incorporated even
  more elaborate transition dynamics.
  
* It allows to track and analyze the number of people in each stage of
  the infection, e.g. how many people had been infected two days ago.
  
  In turn, this information can be connected to the observed data,
  i.e. the number of cases and deaths.

* It can easily be fitted to data using *Stan* ... as we will show below.

## Model fitting

Switch to *Stan* now ...

### Data download and cleaning

```{r}
library(tidyverse)
library(ggthemes)
library(bayesplot)
library(rstan)

options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```

First, we download real-time data ...

```{r}
df_cases <- read_csv("https://data.humdata.org/hxlproxy/api/data-preview.csv?url=https%3A%2F%2Fraw.githubusercontent.com%2FCSSEGISandData%2FCOVID-19%2Fmaster%2Fcsse_covid_19_data%2Fcsse_covid_19_time_series%2Ftime_series_19-covid-Confirmed.csv&filename=time_series_2019-ncov-Confirmed.csv")
df_deaths <- read_csv("https://data.humdata.org/hxlproxy/api/data-preview.csv?url=https%3A%2F%2Fraw.githubusercontent.com%2FCSSEGISandData%2FCOVID-19%2Fmaster%2Fcsse_covid_19_data%2Fcsse_covid_19_time_series%2Ftime_series_19-covid-Deaths.csv&filename=time_series_2019-ncov-Deaths.csv")
df_recovered <- read_csv("https://data.humdata.org/hxlproxy/api/data-preview.csv?url=https%3A%2F%2Fraw.githubusercontent.com%2FCSSEGISandData%2FCOVID-19%2Fmaster%2Fcsse_covid_19_data%2Fcsse_covid_19_time_series%2Ftime_series_19-covid-Recovered.csv&filename=time_series_2019-ncov-Recovered.csv")
```

and clean everything into a single long-formatted data frame.

```{r}
df <- df_cases %>%
    gather(Date, Cases,
           ends_with("/20")) %>%
    full_join(df_deaths %>%
              gather(Date, Deaths,
                     ends_with("/20"))) %>%
    full_join(df_recovered %>%
              gather(Date, Recovered,
                     ends_with("/20"))) %>%
    mutate(Date = parse_date(Date, "%m/%d/%y"))
``` 

Plot data from initial outbreak in Wuhan (province Hubei)

```{r}
df %>%
    filter(`Province/State` == "Hubei") %>%
    gather(Series, Value,
           Cases, Deaths, Recovered) %>%
    ggplot(aes(Date, Value,
               color = Series)) +
    geom_line() +
    scale_color_colorblind() +
    scale_y_log10() +
    theme_tufte()
```

### Stan models

```{stan output.var="model_v2"}
data {
  int<lower=0> T;        // number of observations
  int<lower=0> cases[T]; // total number of cases
  int<lower=1> N;        // population size
}
parameters {
  vector<lower=0>[7] deltaI0; // How many initial values do we need here?
  real<lower=0> beta;
  real<lower=0> tauE;
  real<lower=tauE> tauI;
}
transformed parameters {
  vector[T-1+7] deltaI;

  deltaI[1:7] = deltaI0;
  for (t in 8:(T-1+7)) {
    real S = N - sum(deltaI[1:(t-1)]);
    real E;
    real I;
    real R;

    E = 0;
    for (tau in 1:(t-1))
      E += (1 - inv_logit(8 * (tau - tauE))) * deltaI[t - tau];

    I = - E;
    for (tau in 1:(t-1))
      I += (1 - inv_logit(8 * (tau - tauI))) * deltaI[t - tau];

    R = N - (S + E + I);

    deltaI[t] = beta * I / N * S;
  }
}
model {
  beta ~ normal(0, 1);
  tauE ~ normal(3, 2);
  tauI ~ normal(3 + 5, 2);

  for (t in 8:(T-1+7)) {
    int ti = t - 7;
    int S = N - cases[ti];
    cases[ti + 1] - cases[ti] ~ binomial(S, deltaI[t] / S);
  }  
}
```

